Were the scenario and system details fully described?
Intro with the problem and how we solved this. **(Robert)**



Front end Demo **(Jan and Markus)**



Were the basic requirements (noted above) met? **(Jan)**

For the 8 unique entity types requirement, we fulfilled this with 10 entities: 
Accounts
Address
Badges
Games
Merchandise
Orders
OrderLineItems
Players
Teams
Votes

For the 1 weak entity requirement, we fulfilled this with:
OrderLineItems (no OrderLineItem entry can exist unless the corresponding Order entry exists)

For the 10 relationship types, we fulfilled this with:
Accounts -> Orders (One to Many)
Orders -> OrderLineItems (One to Many)
OrderLineItems -> Merchandise (One to One)
Accounts -> AccountBadge <- Badges (Many to Many)
Accounts -> Address (One to Many)
Accounts -> Votes (One to Optional Many)
Votes ->  Games (One to One)
Games -> Teams (One to Many)
Teams -> Players (One to Many)



Were the structure and results of several well-designed stored procedures presented? **(Markus)**
Due to everyone working remotely, we decided to use a file-based database, SQLite, to house our data. This made it possible to easily pass it back and forth with the source code we worked on. This database management system unfortunately does not allow us to create,save, or run stored procedures. After getting in contact with the Professor, he said not to worry about presenting anything for this section because of this. Just thought we would remind you about this after contacting you a few days ago.



Were the API endpoints functional? **(Robert)**
We can look at the API endpoints by using Swagger which is a similar program to Postman which is built in to ASP.NET Core.
Register User -> Go to POST "/api/Accounts/signup" and run on:
{
  "id": 0,
  "firstName": "Alex",
  "lastName": "Adams",
  "username": "AlexAdams1",
  "email": "alexadams@gmail.com",
  "password": "0ffe1abd1a08215353c233d6e009613e95eec4253832a761af28ff37ac5a150c",
  "profilePic": "Lakers"
}

Get a User -> Go to GET "/api​/Accounts​/{id}" and run on Id 1. Copy response body and paste in POST "/api​/Accounts​/profile" with edits to the username. Run the GET on the same id to see the updated user details. 

Login a User -> Go to POST "/api/Auth" and run on inputs:
{
  "email": "robert@test.com",
  "password": "0ffe1abd1a08215353c233d6e009613e95eec4253832a761af28ff37ac5a150c"
}

For GameDates, this is the information that is dynamically filling our game dates drop down so that users can select the specific date. It is finding all **unique** dates that exist in our Games database and sorting by ascending dates.
Get GameDates -> Go to GET "/api/Games/GameDates" and run

Get Leaderboard -> Go to GET "/api/Leaderboard" and run. This returns all users who are not admins and sorts them by their amount of totalPointsEarned.



Database (tables) **(Jan)**
Lets shift over to DBeaver to talk about the tables we have in our database. On the right you can see each table that we have created. We can take a look at Games to find all the information that is relevant. This tables includes information like the Home and Away Team Ids, Final Scores, and Potential Payouts for either team winning. We can also see the data that was Posted from when we inputted game scores through the admin dashboard.

Lets also take a look at the Votes table. The values AccountId and GameId are referenced to the external Account and Games table respectively, so that the database knows for which Game and Team you are voting for and which Accounts to payout the points to.



SQL Injection Portion **(Robert)**
For preventing SQL injections as outlined as a crucial requirement for the project, this is taken care of by using entity framework. This framework converts all queries in to parameterized sql statements and therefore protect against sql injections such as a: DROP Table USERS query. (example to show on reg page: 
"David ; DELETE FROM Secrets --") I can take a sample SQL injection that tries to truncate a table to show how we are protected. Lets say we are signing up for an account, and an injection is made for the first name field. We can see that the account takes on the first name as seen here, and that's because the parameterized query treats it as a long string instead of a database command. When looking back at DBeaver and refreshing the Secrets table, we can see all the data remains.



Backend code (Controllers) **(Robert)**
For the backend code, lets take a look at the sign up backend API endpoints (AccountsController.cs). At the start we set up the api route end points at line 17 and initialize it by convention to api/[controller] which translates to api/accounts on this instance. We can go down to line 113 and add signup to the api endpoint for the POST in signing up a user. This endpoint accepts a SignUpRequest object (click on it F12) that takes in these properties. We take the properties and set them equal to a new instance of an account entity object. And then add and save it to the Accounts table. Secondly, since this is a new user we award them with the Starter Badge which is done on line 137. This accepts an AccountBadge object (click on it F12) that takes in these properties. We take the properties and set them equal to the new user Id just created along with specifically the starter badge id. Since AccountBadge is a many to many table, we are able to traverse between Accounts and Badges this way. We reply back to React with an AuthResponse that includes the newly created account information that is needed to update the state of the user on the web app.















